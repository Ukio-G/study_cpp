На предыдущем степе в условной спецификации noexcept мы воспользовались тем, что функция swap имеет аргументы нужных нам типов. В тех случаях, когда аргументов нужного типа у функции нет, можно использовать std::declval<T>(), который позволяет "определить" значение типа T в различных контекстах, в т.ч. в noexcept.

Специфицируйте noexcept для шаблонной функции do_math, если известно, что в её реализации значения типа T копируются,  присваиваются и складываются при помощи оператора +.

Для простоты будем считать, что перемещающих методов у типа T нет.

Пример:

bool b1 = noexcept(do_math<int>()); // true

bool b2 = noexcept(do_math<std::string>()); // false